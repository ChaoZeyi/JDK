# Effective java

## Introduction

编程的目的是为了写出清晰、正确、可重用、鲁棒、灵活、可维护的程序。

java语言总共分为四种数据类型：接口interface、类class、数组、基本类型(int)，前三种都是引用类型，类实例和数组都属于对象

## 创建和销毁对象

### 1、使用静态工厂方法来代替构造器

优点：1、名字上更具有可读性，当使用多构造器的重载（存在一些可选参数和必选参数）来创建不同的对象时，只能通过不同的参数列表来区分，而对于静态工厂方法，可以选择多个不同名字的方法。2、不需要在每次调用时都创建一个新对象，返回的可能是缓存的一个对象（基本类型的包装类使用的就是缓存的对象）3、可以返回该类型的子类对象，对于一些抽象类，没法用构造器创建对象，但可以用静态工厂方法创建子类对象，用于隐藏实现类4、可以简化参数化类型的对象创建，类型推导(type inference)

缺点：1、**如果不包含公有的构造器，无法被子类继承**2、他们与其他静态方法实际上没有任何区别，无法区分，当你想要通过静态工厂方法来实例化类时，如果api文档中没有注释，很难找到

### 2、遇到多参数构造器时，考虑使用构建器Builder

构造器含有多个可选参数时，通常情况下是采用重叠构造器对参数进行组合，但这样会产生多个类似的构造器，使用时容易出错。

其中的一个解决办法就是使用javabean模式，调用一个无参构造器创建对象，然后再调用setter方法来设置参数，但这样的话，整个构造过程就被分成了多个函数调用，在构造过程中，java bean可能处于不一致的状态

最好的解决方法是使用构建器Builder模式，利用必要的参数调用构造器或者静态工厂，得到一个builder对象，然后调用setter方法来设置可选参数。

### 3、使用私有构造器构建Singleton类

Singleton类指的是仅允许实例化一次的类，构造器需要保持为私有，有两种实现方法：

1、私有构造器用来实例化公有的静态final域成员变量

2、使用公有的静态工厂方法，返回私有构造器实例化得到的私有的静态final域成员变量

3、使用单元素的枚举类型（最佳）

节省对象创建的开销

### 4、通过私有构造器来强化类的不可实例化

像java.lang.Math等工具类不希望被实例化，实例化对它没有任何意义

只有当类不包含显式的构造器时，编译器才会自动生成缺省的构造器，一旦我们自己声明了构造器，则缺省的构造器失效，所以我们可以声明一个私有的构造器，保证该类永远不能被实例化。但这样就使得该类不能被继承。

### 5、避免创建不必要的对象

一定要分清楚引用变量和对象（或者说是实例）的区别与联系：

对象是由调用构造器而创建的，保存在堆中，是不可见的，所以我们需要声明一个变量指向该对象，对其操作，此时这个变量就是引用变量。

最好是重用对象而不是创建对象，尤其是对于不可变对象或者是已知不会被修改的可变对象，始终可以被重用

构造器每次被调用时都会创建一个新的对象。

### 6、清除过期的对象引用

java具有自动回收垃圾的功能

### 7、避免使用终结方法

我们无法保证终结方法finalize()被及时的执行，所以我们不能依赖于终结方法来释放资源，因为可能到最后一直都没有执行。

相比于终结方法，提供显式的终止方法来释放资源更加的有效，通常与try finally结构结合起来使用。

## 所有对象通用的方法

Object类所有的非final方法：equals, hashCode, toString, clone, finalize，都是为了被子类覆盖

这里需要严格区分覆盖(override)和重载(overload)

重载：对于类中的方法，包括从父类中继承的方法，**方法名相同但参数列表不同**的方法就构成了重载，不用管返回类型和修饰符、抛出的异常

覆盖：也叫重写，通常发生在子类中，当父类中的某个方法不能满足要求时，子类就需要改写父类方法，并且保证**方法名称**，**参数列表**，**返回类型**必须**完全相同**，而且子类方法的访问修饰符的权限不能比父类**低**（确保能访问父类方法的地方也可以访问子类方法）

### 8、覆盖equals

Object类中的equals方法判断的是两对象是否相等，与操作符＝＝功能一致，但通常情况下，会将equals方法覆盖成判断两对象的值是否相等。

当该类的“相等”概念与Object类一致，不关心是否有“相等”这个功能，继承的超类已经覆盖了equals方法并且满足需求，类是私有的equals方法永远不可能被调用时，该类就不要覆盖equals方法。

只有当类具有自己特有的“相等”概念时，才需要覆盖equals方法

自反性、对称性、传递性、一致性、非空性（为了防止空指针异常）

### 9、覆盖equals时必须要覆盖hashCode

两个相等的对象，hashCode也必须相等；两个不相等的对象，hashCode也可能相等。

如果修改了equals方法，使得值相等的两个不同对象也判定为相等，如果不覆盖hashCode，此时两个对象返回得到的hashCode可能不相等，违反了相等对象hashCode也必须相等的规定，所以，必须也要同时覆盖hashCode

最极端的覆盖方式就是，使所有对象都具有相同的散列码，虽然理论上可行但效果是糟糕的，因为这样所有的对象都映射到同一个位置，散列表退化成链表

需要区分hashCode函数和散列函数，首先对于一个对象，先用hashCode函数计算它的散列码，再利用散列（hash）函数，比如取余来计算最终存储位置。

### 10、始终要覆盖toString

Object类的toString方法默认返回的是“类名＋@＋散列码的无符号十六进制表示法”

但其实这种信息并不够清晰，我们可以覆盖成任何我们需要得到的信息，可以指定格式也可以不指定格式

### 11、谨慎的覆盖clone

Object类的clone方法是protected类型，任何实现了Cloneable接口的类都必须覆盖Object类的clone方法，并且是public类型

### 12、考虑实现Comparable接口

compareTo方法作为Comparable接口中唯一的方法，并没有在Object中声明，compareTo方法不但允许简单的等同性比较，还使得实例具有内在的排序关系

当两个不同类的对象比较时，会抛出异常，compareTo不允许不同类之间的比较

## 类和接口

### 13、使类和成员的可访问性最小

设计良好的模块会隐藏所有的内部数据和实现细节，只通过api与其它模块进行通信，这就是封装的概念。好处在于解除各模块之间的耦合关系，使各模块可以独立地开发、测试。

使用访问控制符来控制

private：只有该类可以访问

default：缺省访问类型，也称为包级私有，只有同一个包内的可以访问

protected：同一个包内以及子类可以访问

public：在任何地方都可以访问

子类中的访问级别不允许低于超类中的访问级别

### 14、在公有类中使用公有访问方法而非公有域

### 15、使可变性最小

不可变类指的是实例不能被修改的类，每个实例包含的所有信息都必须在创建的时间就提供，并且在整个生命周期内固定不变，但并不是说所有的实例都一样，每次创建的实例都可能不一样，只是不能再改变。注意和Singleton的区别。

不可变对象本质上是线程安全的，它们不要求同步，可以被自由的共享，但缺点在于对于每个不同的值，都需要一个单独的对象。

除非有很好的理由让类成为可变类，否则就应该是不可变的。

### 16、复合优于继承

继承主要用来实现代码的重用性，但可能存在危险。在一定程度上继承与封装是矛盾的，因为封装强调函数之间的隔离、而继承中子类是依赖于超类的实现细节的，而超类很有可能随着发行版本不同而有所变化，使得子类遭到破坏。

**复合**：添加了一个转发类，有一个私有域，引用超类的一个实例，转发类中直接调用超类的方法得到结果，并不依赖于超类的实现细节，然后子类继承该转发类。

对于两个类A和B，只有两者之间确实存在明确的“ is a“关系的时候，才应该使用继承。

### 17、要么为继承而设计，并提供说明文档，要么就禁止继承

构造器绝不能调用可被覆盖的方法。父类构造器在子类构造器之前运行，如果此时调用被覆盖的方法，则转向子类的覆盖类，但此时子类的构造器还没有调用，所以很可能导致程序失败。

### 18、接口优于抽象类

接口和抽象类的异同点：1、都不能被实例化；2、对于抽象类和接口，如果是普通类实现，则要求实现所有的方法声明，也可以是抽象类实现，则不作要求；3、只允许单继承，但可以同时实现多个接口；4、接口中只有方法声明，但抽象类中允许某些方法的实现；

接口是完全抽象的，不存在方法的实现，与类是完全不同的类型。

抽象类的好处在于，抽象类的演变要比接口的演变容易得多，如果在后续的发行版本中，希望在抽象类添加新的方法，是可以做到的，而接口却不行。

### 19、接口只用于定义类型

当类实现接口时，接口可以充当该类实例的引用类型

接口应该只用来定义类型，而不是导出常量。

### 20、类层次优于标签类

### 21、用函数对象表示策略

### 22、优先考虑静态成员类

嵌套类：定义在一个类的内部的类

嵌套类存在的目的应该只是为它的上层类提供服务，如果嵌套类将来可能会被其他类使用，那么它就应该变成上层类。

嵌套类包含四种：静态类、非静态类、匿名类、局部类；后三种都被称为内部类

静态类是最简单的一种嵌套类，可以把它当作普通的类，只是碰巧被声明在另一个类的内部而已，可以把它当作上层类的一个静态成员。

非静态类的实例与上层类的实例具有关联关系，而且这种关联关系不能被修改。每个实例都**额外包含一个指向上层实例的引用**，需要消耗时间和空间，并且导致上层实例符合垃圾回收时却仍然得以保留。

如果不要求访问上层实例，就尽量声明为静态类

### 泛型

### 23、不要在新代码中使用原生态类型

声明中具有一个或多个类型参数的类或者接口，就是泛型

泛型的好处在于：声明了参数类型，编译器会自动做类型检验，更加安全；消除了许多强制类型转换（所有的object类型都允许加入，但取出的时候需要强制类型转换成需要的类型）

要注意原生态类型List与List<Object>的区别：List<String>是List的一个子类型，却不是List<Object>的子类型；List<Object>属于泛型，是类型安全的。

List<Object>表示可以包含任何对象类型的链表，List<？>表示可以包含某种未知对象类型的链表，？代表通配符，都属于泛型，是类型安全的。

原生态类型只是为了与引入泛型之前的代码进行兼容而提供的。

### 24、消除非受检警告

应该尽可能消除每一个非受检警告。

禁止警告的注解：@SuppressWarnings

### 25、列表优于数组

数组是协变的，如果sub是super的子类型，那么sub[]也是super[]的子类型，而List<sub>就不是List<super>的子类型。

泛型数组是不可编译的。数组是具体化的，不能创建不可具体化类型的数组。

### 26、优先考虑泛型

### 27、优先考虑泛型方法

## 枚举和注解

### 30、用enum代替int常量

枚举类型是指一组常量组成的类型。在引入枚举类型之前，通常的做法是声明一组公有的静态final的成员变量。

枚举常量需要按照构造器的方式来赋值。每个枚举常量都是该枚举类的一个对象，而且是仅有的对象，枚举类无法通过构造器来new对象。

通过静态values方法，可以获取按照声明顺序排列的枚举常量数组。

### 31、用实例域代替序数

### 32、用EnumSet代替位域

### 33、用EnumMap代替序数索引

### 35、注解优于命名模式

注解的前身是命名模式，通过约定的命名模式实现某种处理，比如单元测试的命名模式是每个方法的开头都是test，缺点：1、拼写错误会导致失败；2、无法确保只用于相应的程序元素上；3、没有提供将参数值与程序元素关联起来的好办法

test注解应该用于静态无参的方法

注解不会改变原程序的语义

### 36、坚持使用Override注解

@Override表示子类对父类方法的覆盖

务必保证在覆盖时，使用@Override，减少出错。不然很有可能变成了方法的重载。

### 37、用标记接口定义类型

标记接口是没有包含方法声明的接口

## 方法

### 38、检查参数的有效性

在方法体的开头检查参数，指定参数错误时程序会抛出的异常；对于非公有的函数，可以使用断言（assertion）来检查参数，如果参数错误，则抛出AssertionError

### 40、谨慎设计方法签名

对于参数类型，优先使用接口而不是类

### 41、慎用重载

重载方法的调用是在编译阶段作出决定的，而覆盖方法是在运行阶段进行的

需要区分编译类型和运行类型：

List a = new ArrayList<Integer>();

List是编译类型，ArrayList<Integer>是运行类型。

永远不要使用两个具有相同参数数目的重载方法。

比如list.remove()方法就很容易出错，有两种重载方法

remove(int index)

remove(Object obj)

如果该list要删除的元素正好是整型1，执行list.remove(1)，选择的是第一种重载方法，而不是我们需要的第二种。

### 42、慎用可变参数

可变参数方法接受0个或者多个指定类型的参数，在参数数目不定的情况下，是一种很方便的方式。

### 43、返回零长度的数组或者集合，而不是null

### 44、为所有导出的api元素编写文档注释

传统意义上的api文档是手工生成的，所以保持文档和代码同步是一件很繁琐的事情，javadoc利用特殊格式的文档注释根据源代码自动产生api文档。

文档注释也相当于是一种约定，描述这个方法做了什么，有哪些参数，返回类型是什么，可能抛出哪些异常。

## 通用程序设计

### 45、将局部变量的作用域最小化

较早的程序设计语言要求局部变量在一个代码块的开头进行声明，但其实更提倡在第一次使用它的地方声明，同时进行初始化。

### 46、for-each循环优先于传统的for循环

for-each循环隐藏了迭代器或者索引变量。

for(T e : elements){

...

}

for-each循环对于多个集合的嵌套迭代更有优势。

单纯用于遍历的话，相比于传统的for循环，for-each循环更有优势，并且没有性能损失。

但如果需要对元素重新赋值或者删除，for-each循环就不可用了，还是需要用传统的for循环。

### 47、了解和使用类库

标准类库经过了大量的测试和使用经验，被证明是正确的。

### 48、如果需要精确的答案，请避免使用float和double

在需要精确的数值计算结果时，考虑使用int，long和BigDecimal，BigDecimal是专门用来处理较大小数值的类型，类似的，BigInteger是专门用来处理较大整数值的类型，他们的使用方式都是通过创建对象，调用对象的方法。但性能比不上基本数据类型。

### 49、基本类型优于装箱基本类型

每个基本类型都有一个对应的引用类型，称为装箱基本类型。可以自动装箱和自动拆箱。

基本类型和装箱基本类型主要有三个区别：

- 同一性：两个new Integer(42)得到的是不同的对象
- 装箱基本类型具有初始值null
- 基本类型通常比装箱基本类型更节省时间和空间。

在一项操作中，如果混合使用基本类型和装箱基本类型，则装箱基本类型就会自动拆箱。

大部分情况下使用基本类型，但作为类型参数时必须使用装箱基本类型。

### 50、如果其他类型更合适，则尽量避免使用字符串

如果可以使用更加合适的数据类型，或者可以编写适当的数据类型，就应该避免使用字符串来表示对象。

### 51、当心字符串连接的性能

为连接n个字符串而重复的使用字符串连接操作符（＋）时，需要n的平方级的时间。因为字符串是不可变的。

在需要进行多次字符串修改时，更推荐使用StringBuilder来代替String

### 52、通过接口引用对象

如果有合适的接口类型存在，那么对于参数、返回值、变量和域来说，都应该使用接口类型进行声明。只有当你用构造器创建对象时，才真正需要使用这个对象的实现类。

像最常见的List<String> lists = new ArrayList<String>();就是一种合适的用法。

优点：

- 使用起来更加灵活，可以修改实现类型

### 53、接口优先反射机制

反射：通过程序来访问JVM中已装载的类的信息

要正确使用Java反射机制就得使用java.lang.Class这个类。它是Java反射机制的起源。当一个类被加载以后，Java虚拟机就会自动产生一个Class对象。通过这个Class对象我们就能获得加载到虚拟机当中这个类对象对应的方法、成员以及构造方法的声明和定义等信息。

### 54、谨慎地使用本地方法

本地方法指的是用本地程序设计语言（C或者C++）来编写的特殊方法，本地方法在本地语言中运行，然后返回到java程序设计语言。

优点：

- 访问特定于平台的特性，但随着java平台的不断成熟，它提供了很多以前只在宿主平台存在的特性；
- 访问遗留代码库
- 提高代码性能，但jvm已经越来越快了，并不提倡

缺点：本地语言是与平台相关的，使用本地方法的应用程序也不再是可自由移植的；在进入和退出本地代码时，需要固定的开销。

### 55、谨慎地进行优化

还没有绝对清晰的优化之前，请不要优化。

在每次试图做优化之前和之后，要对性能进行测量。

### 56、遵循普遍接受的命名惯例

命名惯例分为两大类：字面的和语法的

包：层次状的，用句号隔开，是小写字母

类、接口：包含一个或多个单词，每个单词的首字母大写

方法：包含一个或多个单词，除第一个单词外的每个单词的首字母大写

常量域：包含一个或多个大写的单词

## 异常

### 57、只针对异常的情况才使用异常

不要滥用异常，相比于基于异常的模式，应该优先考虑正常模式。

异常是为了在异常情况下使用而设计的，不要将它们用于普通的控制流。

### 58、对可恢复的情况使用受检异常，对编程错误使用运行时异常

所有异常，都继承自java.lang.Throwable类。

Throwable有两个直接子类，Error类和Exception类。

Exception：可从任何标准Java库的类方法，自己的方法以及运行时任何异常中抛出来的基类型。

异常可分为运行时异常（RuntimeException）和受检异常（Checked Exceptions）

受检异常：编译时异常，是编译器在编译时进行校验的，是正常逻辑的一种补偿处理手段，通过throws语句或者try{}cathch{} 语句块来处理。对于可能抛出但并未捕获的所有checkedException都需要使用throws语句声明，比如Java.lang.NoSuchFileException

运行时异常：程序运行过程中可能发生的异常，无需在声明中使用throws语句。当发生运行时异常时，当前线程应该停止，继续执行下去有害无益，比如NullPointerException，ArrayIndexOutOfBoundsException

Error也属于非受检异常，不需要也不应该被捕获。

### 59、避免不必要地使用受检异常

受检异常破坏了封装性，如果修改了方法声明，则所有调用该方法的应用程序都需要修改；

调用包含受检异常的方法，可读性降低

### 60、优先使用标准的异常

### 61、抛出与抽象相对应的异常

### 62、每个方法抛出的异常都要有文档

准确记录每个异常可能抛出的条件，包括受检异常和非受检异常。

### 63、在细节消息中包含捕获失败的信息

为了捕获失败，异常的细节信息应该包含所有对该异常有贡献的参数和域的值。最理想的情况就是，细节消息给出为什么失败的信息，与源文件结合起来进行分析，给出抛出异常所在的文件和行数。

### 64、努力使失败保持原子性

失败的方法调用应该使对象保持在调用之前的状态

### 65、不要忽略异常

禁止使用空的catch块。

## 并发

并发程序设计的难点在于：有更多的东西容易出错，并且错误难以重现。

### 66、同步访问共享的可变数据

关键字synchronized可以保证在同一时刻只有一个线程可以执行某一方法。保证该方法在同一时间面对多个进程，一直处于一致的状态。

如果没有同步，一个线程的变化就不能被其他线程看到。

不可分割的操作被称为原子操作。所谓不可分割是指一个操作从其执行线程以外的其他线程看来，该操作要么已经完成要么尚未开始，也就是说其他线程不会看到该操作的中间结果。如果一个操作是原子操作，那么我们就称该操作具有原子性。

Java语言规范（Java Language Specification，JLS）规定，Java语言中针对long/double型以外的任何变量（包括基础类型变量和引用型变量）进行的读、写操作都是原子操作，即Java语言规范本身并不规定针对long/double型变量进行读、写操作具有原子性。一个long/double型变量的读/写操作在32位Java虚拟机下可能会被分解为两个子步骤（比如先写低32位，再写高32位）来实现，这就导致一个线程对long/double型变量进行的写操作的中间结果可以被其他线程所观察到，即此时针对long/double型变量的访问操作不是原子操作。

原子性保证了互斥访问。

volatile修饰符不执行互斥访问，但可以保证任何线程在读取变量的时候得到的都是最新被修改的值。

所以原子性＋volatile的效果等同于synchronized

### 67、避免过度同步

### 68、executor和task优先于线程

### 71、慎用延迟初始化

延迟到需要的时候才进行初始化。如果永远不需要这个值，这个域就永远不会被初始化

### 72、不要依赖于线程调度器

## 序列化

序列化指的是将一个对象编码成一个字节流，字节流包含对象类型、对象成员变量。相反，从字节流编码中重新构建对象叫做反序列化。一旦对象被序列化后，它的编码就可以从一台正在运行的虚拟机传递到另一台虚拟机，供以后反序列化时用。序列化技术为远程通信提供了标准的对象表示法。

### 74、谨慎地使用Serializable接口

只要在类的声明中加入implements Serializable，该类的实例就可被序列化。

**为什么要序列化**： Java平台允许我们在内存中创建可复用的Java对象，但一般情况下，只有当JVM处于运行时，这些对象才可能存在，即，这些对象的生命周期不会比JVM的生命周期更长。但在现实应用中，就可能要求在JVM停止运行之后能够保存指定的对象，并在将来重新读取被保存的对象。Java对象序列化就能够帮助我们实现该功能。使用Java对象序列化，在保存对象时，会把其状态保存为一组字节，在未来，再将这些字节组装成对象。必须注意地是，对象序列化保存的是对象的"状态"，即它的**成员变量**。由此可知，对象序列化不会关注类中的静态变量。
​    除了在**持久化对象**时会用到对象序列化之外，当使用RMI(远程方法调用)，或在网络中**传递对象**时，都会用到对象序列化。

使用 ObjectInputStream 和 ObjectOutputStream 进行对象的读写

反序列化机制是一个隐藏的构造器，readObject()

默认序列化机制，在序列化对象时，不仅会序列化对象本身，还会序列化该对象引用的其他对象。

### 76、保护性地编写readObject方法

